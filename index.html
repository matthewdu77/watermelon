<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Watermelon by matthewdu77</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Watermelon</h1>
      <h2 class="project-tagline">Concurrent Hash Table</h2>
      <a href="https://github.com/matthewdu77/watermelon" class="btn">View on GitHub</a>
      <a href="https://github.com/matthewdu77/watermelon/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/matthewdu77/watermelon/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="summary" class="anchor" href="#summary" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Summary</h3>

<p>Watermelon is an incomplete concurrent, lock-free implementation of unordered associative arrays in C++. Watermelon exposes supports all the same operations as <code>std::unordered_map</code>, making it an easy drop-in replacement when parallelizing single-threaded code.</p>

<h3>
<a id="background" class="anchor" href="#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Background</h3>

<p>Associative arrays, more commonly referred to as dictionaries, are a vital part of modern software systems. Associative arrays are commonly implemented using hash tables, which even distribute keys across an random-access table. Unlike trees or linked lists, because the keys are so evenly distributed across the hash table, concurrent access to a hash table has low average contention.</p>

<p><code>std::unordered_map</code> supports the normal insertion, deletion, and lookup operations. It also supports iteration, assignment, equality, and swap operations, along with several specializations to decrease the number of data copies. However, <code>std::unordered_map</code> is not thread-safe, and so requires external locking to be used in multi-threaded programs.</p>

<h3>
<a id="approach" class="anchor" href="#approach" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Approach</h3>

<p>Watermelon implements associative arrays with hash tables with closed addressing and separate chaining. Each bucket in the underlying array contains a linked-list which contains the key-value pairs stored by the user. Keys are matched to buckets in the usual way with a hash function modulo the table size.</p>

<p>The linked-lists for each bucket are singly-linked, which allows simple data-structure invariants to be maintained more easily. However, singly-linked lists make node deletion challenging. So instead, nodes are marked for deletion manually by setting a per-node state variable. Once this variable is set, subsequent traversals of the list will ignore this node.</p>

<p>Nodes are reclaimed once the occupancy of the hash table (including 'deleted' nodes) grows too high. A new table is allocated, all nodes from the old table are copied to the new table, and then the old nodes are deleted en masse. Memory is managed with a per-table shared pointer, which prevents any memory from being deallocated before all threads have finished using it.</p>

<p>While the copy operation takes place, all threads operate on both the old and new tables, short-circuiting their work where applicable. The copying thread additionally marks nodes as copied using the state variable to allow subsequent threads to delete elements while the copy takes place.</p>

<h3>
<a id="results" class="anchor" href="#results" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Results</h3>

<p>I was unable to complete the project. C++ is a devil of a language, and attempting to debug the heavily-templated code necessary for compatibility with <code>std::unordered_map</code> ruined my life. As it stands right now, table resizing and recycling are not fully supported, nor are swap semantics.</p>

<p>Furthermore, <code>std::unordered_map</code> returns iterators for every function call. However, in my implementation, iterators are invalidated on certain deletions and on resize operations, so on a resize, no useful work can be performed.</p>

<p>I was not able to get a full test suite working, but I performed preliminary testing, comparing Watermelon to an <code>std::unordered_map</code> protected by an <code>std::mutex</code>. The <code>std::unordered_map</code> outperformed Watermelon by a factor of 3.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/matthewdu77/watermelon">Watermelon</a> is maintained by <a href="https://github.com/matthewdu77">matthewdu77</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
